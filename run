 // åªéœ€é…ç½®è‡ªå·±çš„stravaç„¶åå°†è¯¥ä»£ç å¤åˆ¶å¯¼å…¥ scriptable  å³å¯

async function createWidget() {
  const widget = new ListWidget();
  
  // æ ¹æ®ç³»ç»Ÿå¤–è§‚æ¨¡å¼è®¾ç½®èƒŒæ™¯é¢œè‰²
  if (Device.isUsingDarkAppearance()) {
    widget.backgroundColor = new Color("#1D1D1F");  // æ·±è‰²æ¨¡å¼
  } else {
    widget.backgroundColor = new Color("#FFFFFF");  // æµ…è‰²æ¨¡å¼
  }
  
  widget.setPadding(8, 40, 8, 30);
  
  const mainStack = widget.addStack();
  mainStack.layoutHorizontally();
  
  // å·¦ä¾§è¿åŠ¨æ•°æ®
  const runStack = mainStack.addStack();
  runStack.layoutVertically();
  runStack.size = new Size(190, 0);
  
  // æ·»åŠ é¡¶éƒ¨é—´è·ï¼Œå°†å†…å®¹å‘ä¸‹ç§»åŠ¨
  runStack.addSpacer(10);  // æ·»åŠ 10ç‚¹çš„é¡¶éƒ¨é—´è·
  
  // è¿åŠ¨æ ‡é¢˜è¡Œ
  const runTitleStack = runStack.addStack();
  runTitleStack.layoutHorizontally();
  runTitleStack.centerAlignContent();
  
  const runIcon = runTitleStack.addText("ğŸƒâ€â™‚ï¸ ");
  runIcon.font = Font.systemFont(16);
  
  const activityData = await getRunningData();
  const runTitle = runTitleStack.addText(activityData.type);
  runTitle.textColor = new Color("#64B5F6");
  runTitle.font = Font.boldSystemFont(16);
  runTitle.lineLimit = 1;
  
  runStack.addSpacer(8);
  
  // æ•°æ®æ˜¾ç¤ºè¡Œï¼Œä½¿ç”¨æ°´å¹³å¸ƒå±€
  const dateStack = runStack.addStack();
  dateStack.layoutHorizontally();
  const dateLabel = dateStack.addText("Date:  ");
  dateLabel.textColor = new Color("#999999");
  dateLabel.lineLimit = 1;
  const dateValue = dateStack.addText(activityData.date);
  dateValue.textColor = new Color("#FFFFFF");
  dateValue.lineLimit = 1;
  
  runStack.addSpacer(4);
  
  const distanceStack = runStack.addStack();
  distanceStack.layoutHorizontally();
  const disLabel = distanceStack.addText("Dis:  ");
  disLabel.textColor = new Color("#999999");
  disLabel.lineLimit = 1;
  const disValue = distanceStack.addText(activityData.distance);
  disValue.textColor = new Color("#FFFFFF");
  disValue.lineLimit = 1;
  
  runStack.addSpacer(4);
  
  const paceStack = runStack.addStack();
  paceStack.layoutHorizontally();
  const paceLabel = paceStack.addText("Pace:  ");
  paceLabel.textColor = new Color("#999999");
  paceLabel.lineLimit = 1;
  const paceValue = paceStack.addText(activityData.pace);
  paceValue.textColor = new Color("#FFFFFF");
  paceValue.lineLimit = 1;
  
  // æ·»åŠ é—´è·
  runStack.addSpacer(8);
  
  // æ·»åŠ ç¬¬ä¸€è¡Œåè¨€ï¼Œç¡®ä¿å®Œæ•´æ˜¾ç¤º
  const quoteStack1 = runStack.addStack();
  quoteStack1.layoutHorizontally();
  const quote1 = quoteStack1.addText("Why do u want to climb Mount?");
  quote1.textColor = new Color("#F44336");  // æ”¹ä¸ºçº¢è‰²
  quote1.font = Font.systemFont(10);
  quote1.lineLimit = 1;
  
  // æ·»åŠ å°é—´è·
  runStack.addSpacer(2);
  
  // æ·»åŠ ç¬¬äºŒè¡Œåè¨€
  const quoteStack2 = runStack.addStack();
  quoteStack2.layoutHorizontally();
  const quote2 = quoteStack2.addText("Because it's there.â›°ï¸");
  quote2.textColor = new Color("#64B5F6");  // ä½¿ç”¨è“è‰²çªå‡ºæ˜¾ç¤ºå›ç­”
  quote2.font = Font.italicSystemFont(10);  // ä½¿ç”¨æ–œä½“
  quote2.lineLimit = 1;
  
  // å¢åŠ å¼¹æ€§é—´è·ï¼Œå°†åœ°å›¾æ¨åˆ°æœ€å³è¾¹
  mainStack.addSpacer();
  
  // å³ä¾§åœ°å›¾éƒ¨åˆ†
  try {
    const mapStack = mainStack.addStack();
    mapStack.layoutVertically();
    mapStack.size = new Size(140, 150);
    
    // æ ¹æ®ç³»ç»Ÿå¤–è§‚æ¨¡å¼è®¾ç½®åœ°å›¾èƒŒæ™¯å’Œé˜´å½±
    if (Device.isUsingDarkAppearance()) {
      mapStack.backgroundColor = new Color("#1D1D1F", 0.3);  // æ·±è‰²æ¨¡å¼åŠé€æ˜èƒŒæ™¯
    } else {
      mapStack.backgroundColor = new Color("#000000", 0.05);  // æµ…è‰²æ¨¡å¼æ·¡ç°è‰²èƒŒæ™¯
    }
    
    mapStack.cornerRadius = 10;  // åœ†è§’
    
    // æ·»åŠ é˜´å½±æ•ˆæœ
    mapStack.shadowColor = Color.dynamic(
      new Color("#000000", 0.3),  // æµ…è‰²æ¨¡å¼é˜´å½±
      new Color("#000000", 0.5)   // æ·±è‰²æ¨¡å¼é˜´å½±
    );
    mapStack.shadowRadius = 3;
    mapStack.shadowOffset = new Point(0, 2);
    
    const activities = await getStravaActivities();
    let activityDetails = null;
    
    if (activities?.[0]) {
      activityDetails = await getActivityDetails(activities[0].id);
      
      // æ·»åŠ è¯¦ç»†çš„è°ƒè¯•æ—¥å¿—
      console.log("[Debug] æ´»åŠ¨è¯¦æƒ…:", {
        id: activityDetails?.id,
        name: activityDetails?.name,
        location_city: activityDetails?.location_city,
        location_state: activityDetails?.location_state,
        start_address: activityDetails?.start_address,
        formatted_location: activityDetails?.formatted_location
      });
      
      if (activityDetails) {
        const mapImage = await getMapImage(activityDetails);
        if (mapImage) {
          const mapElement = mapStack.addImage(mapImage);
          mapElement.imageSize = new Size(140, 140);
          
          // æ·»åŠ åœ°å€ä¿¡æ¯
          mapStack.addSpacer(2);
          const cityStack = mapStack.addStack();
          cityStack.layoutHorizontally();
          cityStack.centerAlignContent();
          
          cityStack.addSpacer();
          
          // æ‰“å°æœ€ç»ˆä½¿ç”¨çš„åœ°å€ä¿¡æ¯
          console.log("[Debug] æœ€ç»ˆæ˜¾ç¤ºçš„åœ°å€:", activityDetails.formatted_location || "Unknown");
          
          const locationText = cityStack.addText(activityDetails.formatted_location || "Unknown");
          locationText.textColor = new Color("#999999");
          locationText.font = Font.systemFont(10);
          locationText.centerAlignText();
          
          cityStack.addSpacer();
        } else {
          const noRoute = mapStack.addText("No Route");
          noRoute.textColor = new Color("#999999");
          noRoute.font = Font.systemFont(12);
        }
      }
    } else {
      const noActivity = mapStack.addText("No Activity");
      noActivity.textColor = new Color("#999999");
      noActivity.font = Font.systemFont(12);
    }
  } catch (error) {
    console.error("[Error] åœ°å›¾å¤„ç†å¤±è´¥:", error);
    const errorText = mapStack.addText("Load Failed");
    errorText.textColor = new Color("#FF0000");
    errorText.font = Font.systemFont(12);
  }
  
  // æ ¹æ®ç³»ç»Ÿå¤–è§‚æ¨¡å¼è°ƒæ•´æ–‡å­—é¢œè‰²
  const textColor = Device.isUsingDarkAppearance() ? 
    new Color("#FFFFFF") :  // æ·±è‰²æ¨¡å¼ä¸‹çš„æ–‡å­—é¢œè‰²
    new Color("#000000");   // æµ…è‰²æ¨¡å¼ä¸‹çš„æ–‡å­—é¢œè‰²
    
  const subTextColor = Device.isUsingDarkAppearance() ? 
    new Color("#999999") :  // æ·±è‰²æ¨¡å¼ä¸‹çš„æ¬¡è¦æ–‡å­—é¢œè‰²
    new Color("#666666");   // æµ…è‰²æ¨¡å¼ä¸‹çš„æ¬¡è¦æ–‡å­—é¢œè‰²
  
  // æ›´æ–°æ–‡å­—é¢œè‰²
  dateLabel.textColor = subTextColor;
  dateValue.textColor = textColor;
  disLabel.textColor = subTextColor;
  disValue.textColor = textColor;
  paceLabel.textColor = subTextColor;
  paceValue.textColor = textColor;
  
  // åè¨€çš„é¢œè‰²ä¿æŒä¸å˜ï¼Œå› ä¸ºå®ƒä»¬æœ‰ç‰¹å®šçš„é¢œè‰²ä¸»é¢˜
  
  return widget;
}

async function getRunningData() {
  try {
    console.log("[Debug] å¼€å§‹è·å–è¿åŠ¨æ•°æ®");
    const activities = await getStravaActivities();
    
    if (!activities.length) {
      console.log("[Debug] æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æ´»åŠ¨");
      return defaultData();
    }
    
    const latestActivity = activities[0];
    console.log("[Debug] æœ€æ–°è¿åŠ¨æ´»åŠ¨:", latestActivity ? {
      id: latestActivity.id,
      type: latestActivity.type,
      name: latestActivity.name,
      date: latestActivity.start_date,
      distance: latestActivity.distance,
      time: latestActivity.moving_time
    } : "æœªæ‰¾åˆ°");
    
    if (!latestActivity) {
      console.log("[Debug] æ²¡æœ‰æ‰¾åˆ°è¿åŠ¨æ´»åŠ¨");
      return defaultData();
    }
    
    // å¤„ç†æ•°æ®
    const date = new Date(latestActivity.start_date);
    const formattedDate = `${date.getMonth() + 1}/${date.getDate()}`;
    const distance = (latestActivity.distance / 1000).toFixed(2);
    const paceSeconds = latestActivity.moving_time / (latestActivity.distance / 1000);
    const paceMinutes = Math.floor(paceSeconds / 60);
    const paceRemainingSeconds = Math.floor(paceSeconds % 60);
    const pace = `${paceMinutes}'${paceRemainingSeconds.toString().padStart(2, '0')}"`;
    
    const result = {
      type: activityTypeMap[latestActivity.type] || latestActivity.type,
      date: formattedDate,
      distance: `${distance} km`,
      pace: pace
    };
    
    console.log("[Debug] å¤„ç†åçš„æ•°æ®:", result);
    return result;
    
  } catch (error) {
    console.error("[Error] è·å–è¿åŠ¨æ•°æ®å¤±è´¥:", error.message);
    return defaultData();
  }
}

function defaultData() {
  return {
    type: "No Activity",
    date: "No Record",
    distance: "-- km",
    pace: "--'--\""
  };
}

// æ·»åŠ è¿åŠ¨ç±»å‹æ˜ å°„
const activityTypeMap = {
  'Run': 'Running',
  'Ride': 'Cycling',
  'Swim': 'Swimming',
  'Walk': 'Walking',
  'Hike': 'Hiking',
  'Workout': 'Workout',
  'WeightTraining': 'Weight Training',
  'Yoga': 'Yoga'
};

// ä¿®æ”¹ Strava é…ç½®
const STRAVA_CONFIG = {
  client_id: 106114,
  client_secret: "b345271a3d96b4fbf9698fcc7c50da92f81356aa",
  refresh_token: "b149d8168f0e3c9bc47b44b3a20f0a19a57bad05",
  is_first_time: false
};

async function getStravaAccessToken() {
  try {
    const url = 'https://www.strava.com/oauth/token';
    const req = new Request(url);
    req.method = 'POST';
    req.headers = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };
    
    const params = [
      `client_id=${STRAVA_CONFIG.client_id}`,
      `client_secret=${STRAVA_CONFIG.client_secret}`,
      `refresh_token=${STRAVA_CONFIG.refresh_token}`,
      'grant_type=refresh_token'
    ].join('&');
    
    req.body = params;
    
    const response = await req.loadString();
    const jsonResponse = JSON.parse(response);
    
    if (!jsonResponse.access_token) {
      console.error("[Error] Token å“åº”:", response);
      throw new Error('æ— æ•ˆçš„ token å“åº”');
    }
    
    return jsonResponse.access_token;
  } catch (error) {
    console.error("[Error] è·å– token å¤±è´¥:", error);
    throw error;
  }
}

async function getStravaActivities() {
  try {
    const token = await getStravaAccessToken();
    console.log("[Debug] æˆåŠŸè·å– token");
    
    const url = 'https://www.strava.com/api/v3/athlete/activities?per_page=10';
    const req = new Request(url);
    req.headers = {
      'Authorization': `Bearer ${token}`
    };
    
    const response = await req.loadString();
    console.log("[Debug] API å“åº”:", response.substring(0, 200) + "...");
    
    const data = JSON.parse(response);
    return data;
  } catch (error) {
    console.error("[Error] è·å–æ´»åŠ¨å¤±è´¥:", error);
    throw error;
  }
}

async function getActivityDetails(activityId) {
  try {
    if (!activityId) {
      console.log("[Debug] æ²¡æœ‰æ´»åŠ¨ID");
      return null;
    }
    
    const token = await getStravaAccessToken();
    const url = `https://www.strava.com/api/v3/activities/${activityId}`;
    const req = new Request(url);
    req.headers = {
      'Authorization': `Bearer ${token}`
    };
    
    const response = await req.loadString();
    const data = JSON.parse(response);
    
    let locationInfo = '';
    
    // ä½¿ç”¨èµ·ç‚¹åæ ‡è·å–ä½ç½®ä¿¡æ¯
    if (data.start_latlng?.length === 2) {  // ç®€åŒ–æ¡ä»¶åˆ¤æ–­
      const [lat, lng] = data.start_latlng;
      
      try {
        const nominatimUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=8&addressdetails=1`;
        const geoReq = new Request(nominatimUrl);
        geoReq.headers = {
          'User-Agent': 'Scriptable Widget'
        };
        
        const geoResponse = await geoReq.loadJSON();
        
        // ç›´æ¥ä»åœ°å€ä¸­æå–åŸå¸‚ä¿¡æ¯
        locationInfo = geoResponse.address?.city || 
                      geoResponse.address?.state_district || 
                      geoResponse.address?.municipality || 
                      data.location_city || 
                      "Unknown Location";
      } catch (error) {
        locationInfo = data.location_city || "Unknown Location";
      }
    } else {
      locationInfo = data.location_city || "Unknown Location";
    }
    
    // æ¸…ç†ä½ç½®ä¿¡æ¯ï¼Œåªä¿ç•™åŸå¸‚å
    locationInfo = locationInfo
      .replace(/(å¸‚|åŒº|å¿|è‡ªæ²»åŒº|ç‰¹åˆ«è¡Œæ”¿åŒº|County|District|City|Province|Region)$/i, '')
      .trim();
    
    return {
      ...data,
      formatted_location: locationInfo
    };
    
  } catch (error) {
    console.error("[Error] è·å–æ´»åŠ¨è¯¦æƒ…å¤±è´¥:", error);
    return null;
  }
}

async function getMapImage(activity) {
  try {
    if (!activity?.map?.summary_polyline) {
      console.log("[Debug] æ²¡æœ‰æ‰¾åˆ°è·¯æ•°æ®");
      return null;
    }
    
    const coordinates = decodePolyline(activity.map.summary_polyline);
    console.log("[Debug] è§£ç åçš„åæ ‡ç‚¹æ•°é‡:", coordinates.length);
    
    if (coordinates.length < 2) {
      console.log("[Debug] åæ ‡ç‚¹ä¸è¶³");
      return null;
    }
    
    // è®¡ç®—è¾¹ç•Œ
    const bounds = coordinates.reduce((acc, point) => ({
      minLat: Math.min(acc.minLat, point[0]),
      maxLat: Math.max(acc.maxLat, point[0]),
      minLng: Math.min(acc.minLng, point[1]),
      maxLng: Math.max(acc.maxLng, point[1])
    }), { minLat: 90, maxLat: -90, minLng: 180, maxLng: -180 });
    
    console.log("[Debug] è®¡ç®—çš„è¾¹ç•Œ:", bounds);
    
    // åˆ›å»ºç»˜å›¾ä¸Šä¸‹æ–‡
    const size = 120;
    const context = new DrawContext();
    context.size = new Size(size, size);
    context.opaque = false;
    
    // è®¾ç½®ç»˜å›¾å‚æ•°
    const padding = 10;
    const drawingWidth = size - (padding * 2);
    const drawingHeight = size - (padding * 2);
    
    // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
    const latRange = bounds.maxLat - bounds.minLat;
    const lngRange = bounds.maxLng - bounds.minLng;
    const scale = Math.min(
      drawingWidth / lngRange,
      drawingHeight / latRange
    );
    
    console.log("[Debug] ç»˜å›¾å‚æ•°:", {
      size, padding, scale,
      latRange, lngRange
    });
    
    // è½¬æ¢åæ ‡ç‚¹åˆ°ç”»å¸ƒåæ ‡
    const points = coordinates.map(coord => ({
      x: padding + ((coord[1] - bounds.minLng) * scale),
      y: padding + ((bounds.maxLat - coord[0]) * scale)
    }));
    
    console.log("[Debug] ç¬¬ä¸€ä¸ªç‚¹:", points[0]);
    
    // ç»˜åˆ¶è·¯çº¿
    const path = new Path();
    points.forEach((point, index) => {
      if (index === 0) {
        path.move(new Point(point.x, point.y));
      } else {
        path.addLine(new Point(point.x, point.y));
      }
    });
    
    context.setStrokeColor(new Color("#64B5F6"));
    context.setLineWidth(2);
    context.addPath(path);
    context.strokePath();
    
    // ç»˜åˆ¶èµ·ç‚¹ï¼ˆç»¿è‰²ï¼‰
    const startPath = new Path();
    startPath.addEllipse(new Rect(
      points[0].x - 3,
      points[0].y - 3,
      6,
      6
    ));
    context.setFillColor(new Color("#4CAF50"));
    context.addPath(startPath);
    context.fillPath();
    
    // ç»˜åˆ¶ç»ˆç‚¹ï¼ˆçº¢è‰²ï¼‰
    const endPath = new Path();
    const lastPoint = points[points.length - 1];
    endPath.addEllipse(new Rect(
      lastPoint.x - 3,
      lastPoint.y - 3,
      6,
      6
    ));
    context.setFillColor(new Color("#F44336"));
    context.addPath(endPath);
    context.fillPath();
    
    console.log("[Debug] ç»˜åˆ¶å®Œæˆ");
    return context.getImage();
    
  } catch (error) {
    console.error("[Error] ç»˜åˆ¶å¤±è´¥:", error.message);
    console.error("[Error] é”™è¯¯å †æ ˆ:", error.stack);
    return null;
  }
}

// è§£ç  polyline çš„å‡½æ•°
function decodePolyline(str) {
  const coordinates = [];
  let index = 0;
  let lat = 0;
  let lng = 0;
  
  while (index < str.length) {
    let result = 1;
    let shift = 0;
    let b;
    do {
      b = str.charCodeAt(index++) - 63;
      result += (b & 0x1f) << shift;
      shift += 5;
    } while (b >= 0x20);
    lat += ((result & 1) ? ~(result >> 1) : (result >> 1));
    
    result = 1;
    shift = 0;
    do {
      b = str.charCodeAt(index++) - 63;
      result += (b & 0x1f) << shift;
      shift += 5;
    } while (b >= 0x20);
    lng += ((result & 1) ? ~(result >> 1) : (result >> 1));
    
    coordinates.push([lat * 1e-5, lng * 1e-5]);
  }
  
  return coordinates;
}

if (config.runsInWidget) {
  const widget = await createWidget();
  
  // è®¾ç½®åˆ·æ–°é—´éš”ï¼ˆ1å°æ—¶ï¼‰
  const refreshDate = new Date();
  refreshDate.setHours(refreshDate.getHours() + 1);
  widget.refreshAfterDate = refreshDate;
  
  Script.setWidget(widget);
} else {
  const widget = await createWidget();
  await widget.presentMedium();
}

Script.complete(); 
